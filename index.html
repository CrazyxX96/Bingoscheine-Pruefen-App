<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<title>Bingoschein anlegen & prüfen</title>

<!-- OCR (deferred for faster first paint on iPhone) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js" defer crossorigin="anonymous"></script>

<style>
  :root{
    --app-max: 1000px;      /* EINHEITLICHE MAX-BREITE FÜR ALLES */
    --table-max: 520px;     /* Tabellenbreite (innerhalb der App-Breite) */

    --strike-color: #CA3228; /* Rot */
    --accent: #2F4A93;
    --handle:#00BCD4;
  }

  /* Stabile Scrollbar -> kein Layoutsprung bei Modals */
  html{ overflow-y: scroll; scrollbar-gutter: stable both-edges; }

  *{ -webkit-tap-highlight-color:transparent; box-sizing:border-box; }
  body{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#fff; color:#111;
        padding-left: calc(0px + env(safe-area-inset-left));
        padding-right: calc(0px + env(safe-area-inset-right));
        padding-bottom: calc(0px + env(safe-area-inset-bottom)); }

  /* ZENTRIERTER CONTAINER für alles */
  .container{
    max-width: var(--app-max);
    margin: 0 auto;
    padding: 12px;
    text-align: center;
    position: relative;
    z-index: 1; /* vor den Linien */
  }

  /* VERTIKALE SCHWARZE LINIEN (links/rechts am Container) */
  .container-lines::before,
  .container-lines::after{
    content:"";
    position: fixed;           /* von oben bis unten durchgehend */
    top: 0;
    bottom: 0;
    width: 1px;
    background: #000;
    pointer-events: none;
    z-index: 0;               /* hinter dem Inhalt */
  }
  /* Linke Linie genau an der linken Containerkante */
  .container-lines::before{
    left: calc(50% - (var(--app-max) / 2));
  }
  /* Rechte Linie genau an der rechten Containerkante */
  .container-lines::after{
    left: calc(50% + (var(--app-max) / 2));
  }
  /* Auf kleinen Bildschirmen (Container füllt die Breite) -> Linien ausblenden */
  @media (max-width: 1000px){
    .container-lines::before,
    .container-lines::after{ display:none; }
  }

  .muted{ color:#666; }
  .d-none{ display:none !important; }
  .text-left{ text-align:left; }
  .text-center{ text-align:center; }

  .spacer{ height:16px; }
  .spacer-small{ height:8px; }
  .spacer-large{ height:40px; }

  .bar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; margin:10px 0; }
  input[type="text"], input[type="number"], input[type="file"], input[type="date"], button{
    font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; color:#111;
    -webkit-appearance:none;
  }
  button{ background:#f6f6f6; cursor:pointer; touch-action: manipulation; }
  button:disabled{ opacity:.5; cursor:not-allowed; }

  .section-title{
    text-decoration:underline; font-size:20px;
    margin:20px auto 12px; background:#2F4A93; padding:6px 0; border-radius:4px; color:#fff;
    width: 100%;
  }

  /* Boxen */
  .box{ display:inline-block; padding:10px 14px; border-radius:6px; }
  .box-win{ background:#fff59d; }
  .box-muted{ background:#eee; }

  /* Ergebnisse: Fortschrittsbox nur so breit wie ihr Text */
  #resultsWrap .box{ display:block; width:100%; margin-left:auto; margin-right:auto; }
  #progressBox{ display:inline-block !important; width:auto !important; }

  /* Tabellen – zentriert im Container */
  .table-wrap{ overflow:hidden; position:relative; display:flex; justify-content:center; padding:0 8px; }
  table{ border-collapse:collapse; width:min(100%, var(--table-max)); table-layout:fixed; margin:0 auto; background:#fff; color:#111; }
  th, td{ text-align:center; vertical-align:middle; border:2px solid #444; }
  th{ background:#9DCA43; color:#fff; font-size:20px; height:44px; }
  td{ height:56px; font-size:18px; }

  /* Eingabetabelle */
  #inputTable{ width:min(100%, var(--table-max)); }
  #inputTable td{ background:transparent !important; }
  input.cell-inp{
    width:94%; height:90%; text-align:center;
    font-size:16px; line-height:1.2; padding:2px 4px;
    border:none; outline:none; background:transparent;
    margin:auto; display:block; box-sizing:border-box; color:#111;
  }
  input.cell-inp::placeholder{ font-size:12px; color:#999; }

  .invalid-cell{ border:2px solid #c62828 !important; border-radius:6px; }

  /* Gespeicherte Scheine */
  .cards{ display:flex; flex-direction:column; gap:18px; margin-top:14px; align-items:center; }
  .card-block{ border:1px solid #e2e2e2; border-radius:10px; padding:10px; width:min(100%, var(--table-max)); margin:0 auto; background:#fff; color:#111; }
  .card-header{ display:block; text-align:center; }
  .card-title{ font-weight:600; margin-bottom:8px; }
  .card-actions{ display:flex; gap:8px; justify-content:center; margin:6px 0 10px; }
  .saved-card td{ background:#fff; }
  .saved-card td.hit{ background:#ffff00; font-weight:700; }

  /* Bingo-Linien */
  .strike-line{ position:absolute; height:4px; background:var(--strike-color); transform-origin:left center; pointer-events:none; z-index:5; }

  /* Übersicht gezogene Zahlen */
  .drawn-grid-wrap{ overflow-x:auto; padding:0; display:flex; justify-content:center; margin-top:0; border:none; border-radius:0; }
  #drawnGridTable{ border-collapse:collapse; margin:0 auto; width:min(100%, var(--table-max)); max-width:var(--table-max); table-layout:fixed; border-radius:0; }
  #drawnGridTable th, #drawnGridTable td{ border:2px solid #444; text-align:center; }
  #drawnGridTable th{ background:#000; color:#fff; font-size:20px; height:44px; }
  #drawnGridTable td{ height:44px; font-weight:700; }
  #drawnGridTable .cell-inner{ min-height:36px; display:flex; align-items:center; justify-content:center; }

  .number-badge{ display:inline-block; border-radius:4px; padding:2px 6px; margin:0; font-size:14px; cursor:pointer; user-select:none; border:1px solid transparent; font-weight:700; }
  .badge-all{  background:rgba(76,175,80,0.15);  border-color:rgba(76,175,80,0.25); }
  .badge-some{ background:rgba(255,152,0,0.15);  border-color:rgba(255,152,0,0.25); }
  .badge-miss{ background:rgba(244,67,54,0.15);  border-color:rgba(244,67,54,0.25); } /* rot */
  .badge-neutral{ background:#eee; border-color:#ddd; }

  /* Legende */
  .hint{ font-size:14px; }
  .legend-list{ display:inline-grid; grid-template-columns:auto 1fr; gap:6px 10px; align-items:center; text-align:left; }
  .legend-swatch{ width:18px; height:18px; border-radius:4px; border:1px solid transparent; display:inline-block; }
  .legend-all{  background:rgba(76,175,80,0.15);  border-color:rgba(76,175,80,0.25); }
  .legend-some{ background:rgba(255,152,0,0.15);  border-color:rgba(255,152,0,0.25); }
  .legend-miss{ background:rgba(244,67,54,0.15); border-color:rgba(244,67,54,0.25); } /* Rot-Fix */

  /* Schnellauswahl */
  #quickGridTable th{ background:#9DCA43; color:#fff; }
  #quickGridTable td{ height:44px; }
  #quickGridBody td.q-chosen{ outline:3px solid var(--strike-color); outline-offset:-3px; }
  #quickGridBody td.q-chosen .cell-inner{ opacity:1; font-weight:700; color:var(--strike-color); }
  #quickGridBody td[data-qnum]{ cursor:pointer; }
  #quickGridBody td.q-disabled{ pointer-events:none; }

  /* Eingabefelder untereinander */
  .inputs-column { display:flex; flex-direction:column; gap:8px; width:min(100%, var(--table-max)); margin:0 auto; padding:0 8px;}
  .inputs-column input { width:100%; font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #ccc; box-sizing:border-box; color:#111; background:#fff; }

  /* ===== Foto-Bereich (Crop & Handles) ===== */
  #photoZone{ display:flex; flex-direction:column; align-items:center; gap:10px; }

  .intro-box{
    width: min(100%, 860px); /* schmaler als die Überschrift */
    margin-left:auto; margin-right:auto;
  }

  #photoStage{
    position:relative; max-width:100%; width:min(900px, 100%); aspect-ratio:4/3;
    background:#fafafa; border:1px dashed #bbb; border-radius:8px; overflow:hidden;
    cursor:default; touch-action:none; user-select:none; margin:0 auto;
    -webkit-user-select:none;
  }
  #photoStage.space-pan{ cursor:grab; }
  #photoStage.space-pan.active{ cursor:grabbing; }
  #photoStage img{
    position:absolute; inset:0; width:100%; height:100%; object-fit:contain; pointer-events:none;
    transform-origin:center center; will-change:transform;
  }
  .crop-overlay{ position:absolute; inset:0; pointer-events:auto; }
  .crop-rect{
    position:absolute; border:3px solid var(--handle);
    box-shadow:0 0 0 9999px rgba(0,0,0,.35);
    pointer-events:auto; cursor:move; transform-origin:center center; touch-action:none; z-index:10;
  }
  .grid-line{ position:absolute; background:rgba(255,255,255,.75); }

  .handle{
    position:absolute; width:28px; height:28px; background:var(--handle);
    border:2px solid #fff; border-radius:50%; box-shadow:0 1px 4px rgba(0,0,0,.4);
    cursor:grab; touch-action:none; z-index:11;
  }
  .handle.tl{ left:0;   top:0;   transform:translate(-50%,-50%); }
  .handle.tr{ left:100%; top:0;   transform:translate(50%,-50%); }
  .handle.bl{ left:0;   top:100%; transform:translate(-50%,50%); }
  .handle.br{ left:100%; top:100%; transform:translate(50%,50%); }
  .handle.rot{
    width:26px; height:26px; background:#fff; border:3px solid var(--handle);
    border-radius:50%; position:absolute; left:50%; top:-28px; transform:translate(-50%,-50%); cursor:grab;
  }
  .angle-badge{
    position:absolute; left:50%; top:-48px; transform:translate(-50%, -50%);
    background:rgba(47,74,147,.95); color:#fff; font-size:12px; padding:3px 7px; border-radius:6px;
    pointer-events:none; z-index:12;
  }

  .cell-box{ position:absolute; border:2px dashed rgba(255,255,255,.85); outline:1px solid rgba(0,0,0,.25); box-sizing:border-box; pointer-events:none; }

  #ocrProgressWrap{ width:min(900px, 100%); margin:0 auto; }
  #ocrProgressBar{ height:10px; background:#e0e0e0; border-radius:6px; overflow:hidden; }
  #ocrProgressBar>div{ height:100%; width:0%; background:var(--accent); transition:width .2s ease; }
  #ocrLegend{ font-size:13px; color:#666; text-align:center; }

  @media (max-width:380px){
    td { height:52px; }
    input.cell-inp { font-size:15px; height:92%; }
    input.cell-inp::placeholder { font-size:11px; }
  }

  /* Modal */
  .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:9999; }
  .modal-dialog{ width:min(92vw, 420px); }
  .modal-content{ background:#fff; border-radius:12px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.25); text-align:center; }
  .modal-title{ margin:0 0 8px; font-size:18px; }
  .modal-message{ font-size:16px; }

  /* Zusätzliche Zentrierungssicherung */
  #resultsInner, #cardsSavedBox, #drawProgressBox, #legendBox, #entryHint { margin-left:auto; margin-right:auto; }
</style>
</head>
<body>

<div class="container container-lines">
  <!-- KURZE EINWEISUNG -->
  <div class="bar" style="justify-content:center;">
    <div class="box box-muted hint text-left intro-box">
      <strong>Kurzanleitung</strong>
      <ol style="margin:6px 0 0 18px; padding:0;">
        <li><strong>Foto wählen:</strong> Gut ausgeleuchtetes, gerades Foto des Scheins auswählen.</li>
<div class="spacer-small"></div>
        <li><strong>Ausrichten:</strong> „Zahlentabelle ausrichten“ → Rahmen über die Zahlen legen, ggf. drehen → „Fertig ausgerichtet“.</li>
<div class="spacer-small"></div>
        <li><strong>Erkennen lassen:</strong> Die Zahlen werden automatisch in die Eingabetabelle übertragen (prüfe & ergänze alle Felder).</li>
<div class="spacer-small"></div>
        <li><strong>Schein speichern:</strong> Name/Seriennummer/Losnummer/Datum optional eintragen → „Schein speichern“.</li>
<div class="spacer-small"></div>
        <li><strong>Gezogene Zahlen eintragen:</strong> Über „Zahleneingabe“ (manuell + „Eingabe bestätigen“) oder „Zahlenschnellauswahl“.</li>
<div class="spacer-small"></div>
        <li><strong>Übersicht & Ergebnisse:</strong> Unten siehst du die gezogenen Zahlen als Tabelle, kannst Zahlen entfernen und Bingo-Ergebnisse ansehen.</li>
      </ol>
    </div>
  </div>

  <!-- ======================= -->
  <!-- A) FOTO-BEREICH (BETA) -->
  <!-- ======================= -->
  <h2 id="betaTop" class="section-title">Schein mit Foto anlegen (Beta)</h2>
<div class="spacer-small"></div>
  <div id="photoZone" class="bar" style="flex-direction:column">
    <div class="bar"><input id="uploadInput" type="file" accept="image/*"></div>

    <div id="photoBtnBar" class="bar d-none" style="margin-top:8px;">
      <button id="alignBtn" class="d-none" type="button">📏 Zahlentabelle ausrichten</button>
      <button id="finishAlignBtn" class="d-none" type="button">✅ Fertig ausgerichtet</button>
      <button id="deletePhotoBtn" class="d-none" type="button">🧹 Foto entfernen</button>
    </div>

    <div id="photoSpacerAfterButtons" class="spacer d-none"></div>

    <p id="photoHint" class="muted text-center">
      Bitte ein gerades Foto des Bingoscheins auswählen, um die Zahlen automatisch zu erkennen.
    </p>

    <div id="photoStage" class="d-none" title="Pinch: Zoom • 1-Finger: Bild/Frame ziehen • Kreis oben: drehen">
      <img id="photoImage" alt="Bingoschein" />
      <div class="crop-overlay d-none" id="cropOverlay">
        <div id="cropRect" class="crop-rect" style="left:10%; top:10%; width:80%; height:80%;">
          <div class="grid-line" data-grid="v1"></div>
          <div class="grid-line" data-grid="v2"></div>
          <div class="grid-line" data-grid="v3"></div>
          <div class="grid-line" data-grid="v4"></div>
          <div class="grid-line" data-grid="h1"></div>
          <div class="grid-line" data-grid="h2"></div>
          <div class="grid-line" data-grid="h3"></div>
          <div class="grid-line" data-grid="h4"></div>
          <div id="cellBoxes"></div>
          <div class="handle tl" data-h="tl"></div>
          <div class="handle tr" data-h="tr"></div>
          <div class="handle bl" data-h="bl"></div>
          <div class="handle br" data-h="br"></div>
          <div class="handle rot" data-h="rot" title="Drehen"></div>
          <div class="angle-badge" id="angleBadge">0°</div>
        </div>
      </div>
    </div>

    <div class="mobile-rotate d-none" id="mobileRotate">
      <button id="rotMinus" type="button">↶ −1°</button>
      <button id="rotPlus" type="button">↷ +1°</button>
      <button id="rotReset" type="button">⟲ 0°</button>
    </div>

    <div id="ocrLegend" class="box box-muted hint text-center">
      ℹ️ <strong>Tipp:</strong> Richte den Rahmen nur über den Zahlenfeldern aus. Linien möglichst parallel ausrichten.
    </div>

    <div id="ocrProgressWrap" class="d-none">
      <div id="ocrProgressBar"><div></div></div>
      <div id="ocrStatus" class="muted" style="text-align:center; margin-top:6px;">Bereit…</div>
    </div>
  </div>

  <!-- ======================= -->
  <!-- B) MANUELLER BEREICH -->
  <!-- ======================= -->
  <div class="spacer-large"></div>
  <h2 id="top" class="section-title">Schein anlegen</h2>
  <div class="spacer-large"></div>

  <div class="table-wrap">
    <table id="inputTable" aria-label="Eingabetabelle">
      <thead>
        <tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>
      </thead>
      <tbody id="inputBody">
        <script>
          const COL_RANGES_INPUT = [[1,15],[16,30],[31,45],[46,60],[61,75]];
          document.write(
            Array(5).fill('').map(() =>
              '<tr>' + COL_RANGES_INPUT.map(([min,max]) =>
                `<td><input class="cell-inp" type="number" min="${min}" max="${max}" step="1" placeholder="${min}-${max}"></td>`
              ).join('') + '</tr>'
            ).join('')
          );
        </script>
      </tbody>
    </table>
  </div>

  <div class="inputs-column">
    <div class="spacer-small" aria-hidden="true"></div>
    <input id="cardName"  type="text" placeholder="Scheinname" />
    <input id="serialNo"  type="text" placeholder="Seriennummer" />
    <input id="ticketNo"  type="text" placeholder="Losnummer" />
    <!-- Datum mit Platzhalter-Restore -->
    <input id="drawDate"  type="text" placeholder="Datum"
           onfocus="this.type='date'"
           onblur="if(!this.value) this.type='text'" />
  </div>

  <div class="bar">
    <button id="saveBtn" type="button">💾 Schein speichern</button>
    <button id="saveCancelBtn" class="d-none" type="button">✖️ Abbrechen</button>
    <button id="clearBtn" type="button">♻️ Bereich zurücksetzen</button>
  </div>
  <div id="formError" class="muted" style="min-height:1em;"></div>

  <!-- Sprung-Button zur Zahleneingabe -->
  <div class="bar">
    <button id="goToCheckBtn" type="button">⬇️ Gezogene Zahlen eintragen / auswählen</button>
  </div>

  <!-- ======================= -->
  <!-- D) LISTE – direkt nach „Schein anlegen“ -->
  <!-- ======================= -->
  <div class="spacer-large"></div>
  <h2 class="section-title">Gespeicherte Scheine</h2>
  <div class="spacer-small"></div>

  <div id="cardsSavedBox" class="box box-muted text-center" style="margin-bottom:12px;">
    Es wurden 0 von 50 Scheinen gespeichert
  </div>

  <div class="bar" id="deleteAllBar">
    <button id="deleteAllBtn" type="button">🗑️ Alle Scheine löschen</button>
  </div>
  <div id="afterDeleteSpacer" class="spacer"></div>

  <div class="cards" id="cards"></div>

  <!-- ======================= -->
  <!-- C) GEZOGENE ZAHLEN -->
  <!-- ======================= -->
  <div class="spacer-large"></div>
  <h2 id="checkTop" class="section-title">Gezogene Zahlen eintragen / auswählen</h2>
  <div class="spacer"></div>

  <div class="bar" id="drawButtonsBar">
    <button id="toggleEntryBtn" type="button">✏️ Zahleneingabe</button>
    <button id="toggleQuickBtn" type="button">⚡ Zahlenschnellauswahl</button>
  </div>

  <!-- Spacer Large bei „Schließen“-Zuständen -->
  <div id="entryCloseSpacer" class="spacer-large d-none"></div>
  <div id="quickCloseSpacer" class="spacer-large d-none"></div>

  <!-- Panel: Zahleneingabe -->
  <div id="entryPanel" class="d-none">
    <div class="bar">
      <label for="drawn">Gezogene Zahl(en):</label>
      <input id="drawn" type="text" placeholder="z.B. 16,22,37"
             inputmode="decimal" pattern="[0-9.,\s]*"
             autocomplete="off" autocapitalize="off" spellcheck="false" />
    </div>
    <div class="bar">
      <button id="markBtn" type="button">✅ Eingabe bestätigen</button>
    </div>
  </div>

  <!-- Panel: Schnellauswahl -->
  <div id="quickPanel" class="d-none">
    <div class="table-wrap">
      <table id="quickGridTable" aria-label="Zahlenschnellauswahl">
        <thead>
          <tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>
        </thead>
        <tbody id="quickGridBody">
          <tr><td colspan="5"><div class="cell-inner muted">Lade Schnellauswahl…</div></td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Spacer + Hinweis (sichtbar, wenn ≥1 Zahl existiert) -->
  <div id="spacerBeforeEntryHint" class="spacer-large d-none"></div>
  <div id="entryHint" class="box box-muted hint d-none">
    ℹ️ <strong>Tipp:</strong> Zum Entfernen einer gezogenen Zahl nutze die Übersicht unten.
  </div>

  <div class="spacer-large"></div>

  <!-- ======================= -->
  <!-- C2) ÜBERSICHT DER GEZOGENEN ZAHLEN -->
  <!-- ======================= -->
  <h2 class="section-title">Übersicht - Gezogene Zahlen</h2>
  <div class="spacer-small"></div>

  <div id="drawProgressBox" class="box box-muted text-center" style="margin-bottom:12px;">
    Es wurden noch keine Zahlen gezogen
  </div>

  <div class="spacer-small"></div>

  <div class="drawn-grid-wrap d-none" id="drawnGridWrap">
    <table id="drawnGridTable" aria-label="Gezogene Zahlen als Bingo-Tabelle">
      <thead>
        <tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>
      </thead>
      <tbody id="drawnGridBody">
        <tr><td colspan="5"><div class="cell-inner muted">Noch keine Zahlen vorhanden</div></td></tr>
      </tbody>
    </table>
  </div>

  <div class="spacer"></div>

  <div id="drawnHint" class="box box-muted hint d-none text-left">
    ℹ️&nbsp; <strong>Vertippt?</strong> Klicke auf eine gezogene Zahl, um sie wieder zu entfernen.
  </div>

  <!-- Reihenfolge: Trefferampel über Reset -->
  <div id="spacerAfterHint1" class="spacer d-none"></div>

  <!-- Trefferampel -->
  <div class="bar d-none" id="highlightBar">
    <button id="highlightToggleBtn" type="button">🎯 Trefferampel aktivieren</button>
  </div>

  <!-- Legende -->
  <div id="legendBox" class="box box-muted hint d-none text-left" style="margin-top:10px;">
    <div class="legend-list">
      <span class="legend-swatch legend-all" aria-hidden="true"></span>
      <span>= Zahl ist auf <strong>allen</strong> gespeicherten Scheinen vorhanden</span>

      <span class="legend-swatch legend-some" aria-hidden="true"></span>
      <span>= Zahl ist auf <strong>mindestens einem</strong> gespeicherten Schein vorhanden</span>

      <span class="legend-swatch legend-miss" aria-hidden="true"></span>
      <span>= Zahl ist auf <strong>keinem</strong> gespeicherten Schein vorhanden</span>
    </div>
  </div>

  <!-- Kleiner Spacer, dann Reset -->
  <div id="spacerAfterReset1" class="spacer d-none"></div>
  <div class="bar d-none" id="resetBar">
    <button id="resetMarksBtn" type="button">🔄 Alle Zahlen zurücksetzen</button>
  </div>

  <!-- ======================= -->
  <!-- E) BINGO-ERGEBNISSE -->
  <!-- ======================= -->
  <div class="spacer-large"></div>
  <h2 class="section-title">Bingo-Ergebnisse</h2>
  <div class="spacer-small"></div>

  <div id="resultsWrap" class="bar" style="justify-content:center;">
    <div id="resultsInner" style="width:min(100%, var(--table-max)); text-align:center; margin-left:auto; margin-right:auto;">
      <div id="progressBox" class="box box-muted text-center" style="margin-bottom:12px;">
        Es wurden noch keine Zahlen gezogen
      </div>
<div class="spacer-small"></div>
      <div id="statusBox" class="box box-muted text-center d-none" aria-live="polite">
        <h3 id="statusTitle" style="margin:0;"></h3>
        <div id="statusSubtitle" class="muted" style="margin-top:6px;"></div>
        <div id="statusCounts" class="muted d-none" style="margin-top:8px; font-weight:700;"></div>
      </div>
    </div>
  </div>
  <div class="spacer"></div>
  <div class="bar">
    <button id="backToCheckBtn" type="button">⬆️ Gezogene Zahlen eintragen / auswählen</button>
  </div>

  <div class="spacer-large"></div><div class="spacer-large"></div>
</div> <!-- /.container -->

<!-- Modal (OK) -->
<div id="appModal" class="modal-backdrop d-none" aria-hidden="true">
  <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="appModalTitle">
    <div class="modal-content">
      <h3 id="appModalTitle" class="modal-title">Hinweis</h3>
      <div id="appModalMsg" class="modal-message"></div>
      <div class="bar" style="margin-top:14px;">
        <button id="appModalOk" type="button" autofocus>OK</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal (Bestätigen) -->
<div id="confirmModal" class="modal-backdrop d-none" aria-hidden="true">
  <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="confirmModalTitle">
    <div class="modal-content">
      <h3 id="confirmModalTitle" class="modal-title">Bestätigen</h3>
      <div id="confirmModalMsg" class="modal-message"></div>
      <div class="bar" style="margin-top:14px;">
        <button id="confirmCancel" type="button">Abbrechen</button>
        <button id="confirmOk" type="button" autofocus>OK</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const STORAGE_KEY='gb-bingo-v90';
  const MAX_CARDS=50;
  const COL_RANGES=[[1,15],[16,30],[31,45],[46,60],[61,75]];
  const MAX_DRAWN = 22;

  function $(id){ return document.getElementById(id); }
  function show(el){ if(el) el.classList.remove('d-none'); }
  function hide(el){ if(el) el.classList.add('d-none'); }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function isSmall(){ return window.matchMedia('(max-width: 600px)').matches; }

  /* DOM-Referenzen */
  const cardName = $('cardName');
  const serialNo = $('serialNo');
  const ticketNo = $('ticketNo');
  const drawDate = $('drawDate');
  const inputBody = $('inputBody');
  const saveBtn = $('saveBtn');
  const saveCancelBtn = $('saveCancelBtn');
  const clearBtn = $('clearBtn');

  const goToCheckBtn = $('goToCheckBtn');

  const cardsWrap = $('cards');

  const toggleEntryBtn = $('toggleEntryBtn');
  const toggleQuickBtn = $('toggleQuickBtn');
  const entryPanel = $('entryPanel');
  const quickPanel = $('quickPanel');
  const quickGridBody = $('quickGridBody');

  const drawn   = $('drawn');
  const markBtn = $('markBtn');
  const resetBtn= $('resetMarksBtn');

  const formError = $('formError');

  const drawnGridWrap = $('drawnGridWrap');
  const drawnGridBody = $('drawnGridBody');

  const resultsWrap    = $('resultsWrap');
  const backToCheckBtn = $('backToCheckBtn');

  const statusBox      = $('statusBox');
  const statusTitle    = $('statusTitle');
  const statusSubtitle = $('statusSubtitle');
  const statusCounts   = $('statusCounts');

  const progressBox    = $('progressBox');
  const drawProgressBox = $('drawnGridBox') || $('drawProgressBox');

  const drawnHint = $('drawnHint');
  const legendBox = $('legendBox');
  const highlightToggleBtn = $('highlightToggleBtn');

  const spacerAfterHint1 = $('spacerAfterHint1');
  const spacerAfterReset1 = $('spacerAfterReset1');
  const resetBar = $('resetBar');
  const highlightBar = $('highlightBar');

  const cardsSavedBox = $('cardsSavedBox');
  const deleteAllBar = $('deleteAllBar');
  const afterDeleteSpacer = $('afterDeleteSpacer');
  const deleteAllBtn = $('deleteAllBtn');

  const entryHint = $('entryHint');
  const spacerBeforeEntryHint = $('spacerBeforeEntryHint');
  const entryCloseSpacer = $('entryCloseSpacer');
  const quickCloseSpacer = $('quickCloseSpacer');

  /* Foto */
  const uploadInput = $('uploadInput');
  const alignBtn = $('alignBtn');
  const finishAlignBtn = $('finishAlignBtn');
  const deletePhotoBtn = $('deletePhotoBtn');
  const photoStage = $('photoStage');
  const photoImage = $('photoImage');
  const cropOverlay = $('cropOverlay');
  const cropRect = $('cropRect');
  const angleBadge = $('angleBadge');
  const ocrProgressWrap = $('ocrProgressWrap');
  const ocrProgressBarInner = $('ocrProgressBar')?.firstElementChild;
  const ocrStatus = $('ocrStatus');
  const photoBtnBar = $('photoBtnBar');
  const photoSpacerAfterButtons = $('photoSpacerAfterButtons');
  const photoHint = $('photoHint');
  const mobileRotate = $('mobileRotate');

  /* Scroll Lock (für Modals) */
  let __lockScrollY = 0;
  function lockScroll(){
    __lockScrollY = window.scrollY || window.pageYOffset || 0;
    document.body.style.position = 'fixed';
    document.body.style.top = `-${__lockScrollY}px`;
    document.body.style.left = '0';
    document.body.style.right = '0';
    document.body.style.width = '100%';
  }
  function unlockScroll(){
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.left = '';
    document.body.style.right = '';
    document.body.style.width = '';
    window.scrollTo(0, __lockScrollY);
  }

  /* ===== Fokus-Helfer (A11y) ===== */
  function moveFocusTo(el){
    if(!el) return;
    const hadTabindex = el.hasAttribute('tabindex');
    if(!hadTabindex) el.setAttribute('tabindex','-1');
    try { el.focus({ preventScroll:true }); } catch {}
    if(!hadTabindex){
      el.addEventListener('blur', ()=> el.removeAttribute('tabindex'), { once:true });
    }
  }
  function focusFallback(){
    return document.querySelector('#checkTop') || document.querySelector('#top') || document.body;
  }

  /* ====== Deferred Scroll zu Ergebnissen ====== */
  let modalOpen = false;
  let pendingResultsScroll = false;

  function scrollResultsNow(){
    try {
      resultsWrap?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    } catch {}
  }
  function scheduleResultsScroll(){
    pendingResultsScroll = true;
    setTimeout(()=>{
      if(!modalOpen && pendingResultsScroll){
        scrollResultsNow();
        pendingResultsScroll = false;
      }
    }, 0);
  }
  function onModalClosed(){
    modalOpen = false;
    if(pendingResultsScroll){
      scrollResultsNow();
      pendingResultsScroll = false;
    }
  }

  function showModal(message){
    return new Promise((resolve)=>{
      const modal=$('appModal'), msgEl=$('appModalMsg'), okBtn=$('appModalOk');
      const container = document.querySelector('.container');
      const lastFocus = document.activeElement;

      msgEl.textContent=message||'';
      modal.classList.remove('d-none');
      modal.setAttribute('aria-hidden','false');
      modalOpen = true;
      lockScroll();
      container?.setAttribute('inert','');

      function close(){
        // Fokus aus dem Modal holen, bevor aria-hidden gesetzt wird
        if (modal.contains(document.activeElement)) {
          if (lastFocus && document.contains(lastFocus)) moveFocusTo(lastFocus);
          else moveFocusTo(focusFallback());
        }
        container?.removeAttribute('inert');

        modal.classList.add('d-none');
        modal.setAttribute('aria-hidden','true');

        okBtn.removeEventListener('click', onOk);
        document.removeEventListener('keydown', onKey);
        unlockScroll();
        onModalClosed();
        resolve();
      }
      function onOk(){ close(); }
      function onKey(e){ if(e.key==='Enter' || e.key===' ' || e.key==='Escape'){ e.preventDefault(); close(); } }
      okBtn.addEventListener('click', onOk, {once:true});
      document.addEventListener('keydown', onKey, {once:true});
      setTimeout(()=>{ try{ okBtn.focus(); }catch{} },0);
    });
  }

  function showConfirm(message,opts){
    opts = opts || {};
    const okText = opts.okText || 'OK';
    const cancelText = opts.cancelText || 'Abbrechen';
    return new Promise((resolve)=>{
      const modal=$('confirmModal'), msgEl=$('confirmModalMsg'), okBtn=$('confirmOk'), cancelBtn=$('confirmCancel');
      const container = document.querySelector('.container');
      const lastFocus = document.activeElement;

      msgEl.textContent=message||''; okBtn.textContent=okText; cancelBtn.textContent=cancelText;

      modal.classList.remove('d-none');
      modal.setAttribute('aria-hidden','false');
      modalOpen = true;
      lockScroll();
      container?.setAttribute('inert','');

      function cleanup(){
        // Fokus aus dem Modal holen, bevor aria-hidden gesetzt wird
        if (modal.contains(document.activeElement)) {
          if (lastFocus && document.contains(lastFocus)) moveFocusTo(lastFocus);
          else moveFocusTo(focusFallback());
        }
        container?.removeAttribute('inert');

        okBtn.removeEventListener('click', onOk);
        cancelBtn.removeEventListener('click', onCancel);
        document.removeEventListener('keydown', onKey);

        modal.classList.add('d-none');
        modal.setAttribute('aria-hidden','true');

        unlockScroll();
        onModalClosed();
      }
      function onOk(){ cleanup(); resolve(true); }
      function onCancel(){ cleanup(); resolve(false); }
      function onKey(e){ if(e.key==='Escape'){ e.preventDefault(); onCancel(); } if(e.key==='Enter'){ e.preventDefault(); onOk(); } }
      okBtn.addEventListener('click', onOk);
      cancelBtn.addEventListener('click', onCancel);
      document.addEventListener('keydown', onKey);
      setTimeout(()=>{ try{ okBtn.focus(); }catch{} },0);
    });
  }

  /* ===== State ===== */
  let allDrawnNumbers=[];
  let editIndex = null;
  let lastResultsSignature = '';
  let jumpedOn22 = false;
  let highlightsOn = false;

  // Foto-Interaktion
  let currentObjectURL=null, hasImage=false, alignActive=false;
  let imgScale=1, imgOffset={x:0,y:0}, cropAngleDeg=0;

  /* ===== Storage ===== */
  function loadAll(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY))||[] }catch(e){ return [] } }
  function saveAll(arr){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }catch(e){ console.error('localStorage Fehler', e); } }

  /* ===== Helpers ===== */
  function formatDate(value){
    if(!value) return '';
    if(/^\d{4}-\d{2}-\d{2}$/.test(value)){ const y=value.slice(0,4), m=value.slice(5,7), d=value.slice(8,10); return `${d}.${m}.${y}`; }
    if(/^\d{2}\.\d{2}\.\d{4}$/.test(value)) return value;
    return value;
  }

  function getInputs(){ return Array.from(inputBody.querySelectorAll('input.cell-inp')); }
  function readNumbers(){ return getInputs().map(i => (i.value||'').trim()); }
  function clearInput(){
    getInputs().forEach(i=>i.value='');
    cardName.value=''; serialNo.value=''; ticketNo.value='';
    drawDate.value=''; drawDate.type='text'; drawDate.placeholder='Datum';
    formError.textContent=''; liveValidate();
  }
  function hasDup(a){ const v=a.filter(x=>x!==''); return new Set(v).size!==v.length; }

  function liveValidate(){
    const inputs = getInputs();
    const values = inputs.map(i => (i.value || '').trim());
    inputs.forEach(i => i.classList.remove('invalid-cell'));
    const anyFilled = values.some(v => v !== '');
    values.forEach((v, i) => {
      const [min,max] = COL_RANGES[i % 5];
      const n = Number(v);
      if (v !== '' && (Number.isNaN(n) || !Number.isInteger(n) || n < min || n > max)) {
        inputs[i].classList.add('invalid-cell');
      }
      if (anyFilled && v === '') {
        inputs[i].classList.add('invalid-cell');
      }
    });
    const seen = new Map();
    values.forEach((val, idx) => {
      if (val === '') return;
      if (seen.has(val)) {
        inputs[idx].classList.add('invalid-cell');
        inputs[seen.get(val)].classList.add('invalid-cell');
      } else {
        seen.set(val, idx);
      }
    });
  }

  function validate(nums){
    const errs=[];
    nums.forEach((v,i)=>{
      const [min,max]=COL_RANGES[i%5]; const n=Number(v);
      if(v===''||Number.isNaN(n)||!Number.isInteger(n)||n<min||n>max){
        errs.push('E'); const inp=getInputs()[i];
        if(inp){ inp.classList.add('invalid-cell'); }
      }
    });
    const seen=new Map();
    nums.forEach((val,idx)=>{ if(val==='')return;
      if(seen.has(val)){
        const ins=getInputs();
        ins[idx].classList.add('invalid-cell');
        ins[seen.get(val)].classList.add('invalid-cell');
      } else seen.set(val,idx);
    });
    return errs;
  }

  function countCardsContainingNumber(numStr){
    const d=loadAll(); const n=Number(numStr);
    if(!Number.isInteger(n)) return 0;
    let cnt=0;
    for(const c of d){
      if(c && Array.isArray(c.numbers) && c.numbers.includes(String(n))) cnt++;
    }
    return cnt;
  }

  function updateCardsSavedBox(count){
    if (count === 0){
      cardsSavedBox.textContent = 'Es wurde kein Schein gespeichert';
    } else if (count === 1){
      cardsSavedBox.textContent = 'Es wurde 1 von 50 Scheinen gespeichert';
    } else {
      cardsSavedBox.textContent = 'Es wurden ' + count + ' von 50 Scheinen gespeichert';
    }
  }

  function renderAllCards(){
    const d=loadAll();
    cardsWrap.innerHTML='';

    deleteAllBar.classList.toggle('d-none', d.length===0);
    afterDeleteSpacer.classList.toggle('d-none', d.length===0);

    updateCardsSavedBox(d.length);

    if(d.length===0){
      const empty=document.createElement('div');
      empty.className='empty';
      empty.innerHTML = `
        <div class="spacer-large" aria-hidden="true"></div>
        <button id="gotoTop" type="button">Jetzt Schein anlegen</button>
      `;
      cardsWrap.appendChild(empty);
      $('gotoTop')?.addEventListener('click',()=>{ $('top').scrollIntoView({behavior:"smooth"}); });
    }else{
      d.forEach((c,i)=>{
        const wrap=document.createElement('div');
        wrap.className='card-block';

        const header=document.createElement('div'); header.className='card-header';
        const title=document.createElement('div'); title.className='card-title';
        const parts=[`#${i+1} – ${c.name||'Unbenannt'}`];
        if(c.serialNo) parts.push(`Serie: ${c.serialNo}`);
        if(c.ticketNo) parts.push(`Los: ${c.ticketNo}`);
        const formattedDate = formatDate(c.drawDate);
        if(formattedDate) parts.push(`Datum: ${formattedDate}`);
        title.textContent=parts.join(' • ');
        header.appendChild(title);

        const actions=document.createElement('div'); actions.className='card-actions';
        const edit=document.createElement('button'); edit.textContent='✏️ Bearbeiten'; edit.dataset.act='edit'; edit.dataset.idx=i; edit.type='button';
        const del=document.createElement('button'); del.textContent='🗑️ Löschen'; del.dataset.act='delete'; del.dataset.idx=i; del.type='button';
        actions.appendChild(edit); actions.appendChild(del);

        wrap.appendChild(header);
        wrap.appendChild(actions);

        const tw=document.createElement('div'); tw.className='table-wrap';
        const t=document.createElement('table'); t.classList.add('saved-card');
        const thead=document.createElement('thead'); thead.innerHTML='<tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>';
        const tb=document.createElement('tbody');
        for(let r=0;r<5;r++){
          const tr=document.createElement('tr');
          for(let c2=0;c2<5;c2++){
            const val = c.numbers[r*5+c2]||'';
            const td=document.createElement('td');
            td.textContent = val;
            td.dataset.num = String(val);
            tr.appendChild(td);
          }
          tb.appendChild(tr);
        }
        t.appendChild(thead); t.appendChild(tb); tw.appendChild(t); wrap.appendChild(tw);
        cardsWrap.appendChild(wrap);
      });
    }

    applyHitsFromDrawnNumbers();
    updateUnifiedList();
    updateAll();
  }

  function lineSets(tb){
    const rows=Array.from(tb.querySelectorAll('tr')); const sets=[];
    for(let r=0;r<5;r++){ sets.push([0,1,2,3,4].map(c=>rows[r].children[c])); }
    for(let c=0;c<5;c++){ sets.push([0,1,2,3,4].map(r=>rows[r].children[c])); }
    sets.push([0,1,2,3,4].map(i=>rows[i].children[i]));
    sets.push([0,1,2,3,4].map(i=>rows[i].children[4-i]));
    return sets;
  }
  function drawLine(container, cells){
    const f=cells[0].getBoundingClientRect(), l=cells[cells.length-1].getBoundingClientRect(), ct=container.getBoundingClientRect();
    const x1=(f.left+f.width/2)-ct.left+container.scrollLeft, y1=(f.top+f.height/2)-ct.top+container.scrollTop;
    const x2=(l.left+l.width/2)-ct.left+container.scrollLeft, y2=(l.top)+(l.height/2)-ct.top+container.scrollTop;
    const dx=x2-x1, dy=y2-y1, len=Math.hypot(dx,dy), ang=Math.atan2(dy,dx);
    const line=document.createElement('div'); line.className='strike-line';
    line.style.left=`${x1}px`; line.style.top=`${y1-2}px`; line.style.width=`${len}px`; line.style.transform=`rotate(${ang}rad)`;
    container.appendChild(line);
  }
  function remLines(container){ container.querySelectorAll('.strike-line').forEach(e=>e.remove()); }

  function countWins(tw){
    const tb=tw.querySelector('tbody'); remLines(tw); let w=0;
    lineSets(tb).forEach(cs=>{ if(cs.every(td=>td.classList.contains('hit'))){ w++; drawLine(tw,cs); } });
    return w;
  }

  function bingoLabel(w){
    switch(w){
      case 1: return 'Bingo';
      case 2: return 'Doppelbingo';
      case 3: return 'Dreifachbingo';
      case 4: return 'Vierfachbingo';
      case 5: return 'Fünffachbingo';
      default: return `${w}-fachbingo`;
    }
  }

  function refreshProgressBox(){
    const x = allDrawnNumbers.length;
    const text = (x === 0) ? 'Es wurden noch keine Zahlen gezogen'
              : (x === 1 ? 'Es wurde 1 von 22 Zahlen gezogen'
                         : `Es wurden ${x} von 22 Zahlen gezogen`);
    progressBox.innerHTML = text;
    ($('drawProgressBox')||{}).innerHTML = text;
  }

  function setEntryHintVisibility(on){
    if(on){ show(spacerBeforeEntryHint); show(entryHint); }
    else{ hide(spacerBeforeEntryHint); hide(entryHint); }
  }

  function setNumbersDependentUI(on){
    if(on) show(drawnGridWrap); else hide(drawnGridWrap);
    if(on) show(drawnHint); else hide(drawnHint);

    if(on){ show(spacerAfterHint1); show(highlightBar); } else { hide(spacerAfterHint1); hide(highlightBar); hide(legendBox); }

    if(on && highlightsOn) show(legendBox); else if(!highlightsOn) hide(legendBox);

    if(on){ show(spacerAfterReset1); show(resetBar); } else { hide(spacerAfterReset1); hide(resetBar); }

    setEntryHintVisibility(on);
  }

  function updateBackToCheckButtonVisibility(){
    const hideBtn = allDrawnNumbers.length === MAX_DRAWN;
    backToCheckBtn.classList.toggle('d-none', hideBtn);
  }

  function scrollToResultsIfFull(){
    if (allDrawnNumbers.length === MAX_DRAWN && !jumpedOn22){
      jumpedOn22 = true;
      scheduleResultsScroll();
    }
  }

  function updateAll(){
    const wraps = Array.from(cardsWrap.children);
    const buckets = new Map();
    let totalWithAny = 0;

    refreshProgressBox();
    setNumbersDependentUI(allDrawnNumbers.length > 0);
    updateBackToCheckButtonVisibility();

    if (allDrawnNumbers.length === 0) {
      statusBox.classList.add('d-none');
      statusTitle.textContent = '';
      statusSubtitle.textContent = '';
      statusCounts.textContent = '';
      statusCounts.classList.add('d-none');
      statusBox.classList.remove('box-win');
      statusBox.classList.add('box-muted');
      lastResultsSignature = 'none';
      return;
    } else {
      statusBox.classList.remove('d-none');
    }

    wraps.forEach((wrap)=>{
      const t=wrap.querySelector('table.saved-card'); if(!t) return;
      const tw=t.closest('.table-wrap'); if(!tw) return;
      const wins = countWins(tw);
      if(wins>0){ totalWithAny++; buckets.set(wins, (buckets.get(wins)||0)+1); }
    });

    if(allDrawnNumbers.length === MAX_DRAWN && totalWithAny === 0){
      statusTitle.textContent = 'Heute leider kein Glück gehabt 😢';
      statusSubtitle.textContent = '';
      statusCounts.innerHTML = 'Vielleicht klappt’s beim nächsten Mal! 🤞';
      statusCounts.classList.remove('d-none');
      statusBox.classList.add('box-muted');
      statusBox.classList.remove('box-win');

      const signature = 'no-bingo-22';
      if(signature !== lastResultsSignature){
        scheduleResultsScroll();
        lastResultsSignature = signature;
      }
      return;
    }

    if(totalWithAny > 0){
      const parts = [...buckets.entries()].sort((a,b)=>a[0]-b[0]).map(([w,count]) => `${count}× ${bingoLabel(w)}`);
      statusTitle.textContent = '🎉 Du hast gewonnen!';
      statusSubtitle.textContent = '';
      statusCounts.innerHTML = parts.join(' • ');
      statusCounts.classList.remove('d-none');
      statusBox.classList.remove('box-muted');
      statusBox.classList.add('box-win');

      const signature = parts.join('|');
      if(signature !== lastResultsSignature){
        scheduleResultsScroll();
        lastResultsSignature = signature;
      }
    } else {
      statusTitle.textContent = 'Noch kein Bingo';
      statusSubtitle.textContent = '(Prüfung läuft über alle gespeicherten Scheine)';
      statusCounts.textContent = '';
      statusCounts.classList.add('d-none');
      statusBox.classList.add('box-muted');
      statusBox.classList.remove('box-win');
      lastResultsSignature = '';
    }
  }

  function applyHitsFromDrawnNumbers(){
    cardsWrap.querySelectorAll('.saved-card td.hit').forEach(td=>td.classList.remove('hit'));
    for(const n of allDrawnNumbers){ setHitForNumber(n, true); }
  }

  function enterEditMode(index){
    const d = loadAll(); const card = d[index]; if(!card) return;
    const inputs=getInputs();
    inputs.forEach((inp,j)=>{ inp.value=card.numbers[j]||''; });
    cardName.value=card.name||'';
    serialNo.value=card.serialNo||'';
    ticketNo.value=card.ticketNo||'';
    drawDate.value=card.drawDate||'';

    if (drawDate.value) { drawDate.type = 'date'; } else { drawDate.type = 'text'; drawDate.placeholder = 'Datum'; }

    liveValidate();
    editIndex = index;
    saveBtn.textContent = '💾 Änderungen speichern';
    show(saveCancelBtn);
    $('top').scrollIntoView({behavior:'smooth', block:'start'});
  }
  function exitEditMode(){
    editIndex = null;
    saveBtn.textContent = '💾 Schein speichern';
    hide(saveCancelBtn);
  }
  async function saveCard(){
    formError.textContent='';
    const name=cardName.value.trim();
    const nums=readNumbers();
    liveValidate();
    const errs=validate(nums);
    if(errs.length){
      await showModal('Bitte alle 25 Felder korrekt füllen.');
      return;
    }
    if(hasDup(nums)){
      await showModal('Keine doppelten Zahlen pro Schein erlaubt.');
      return;
    }
    const d=loadAll();
    const payload = { 
      name,
      serialNo: serialNo.value.trim(),
      ticketNo: ticketNo.value.trim(),
      drawDate: drawDate.value || '',
      numbers:nums 
    };
    if(editIndex!==null){
      if(!d[editIndex]){
        await showModal('Schein nicht mehr vorhanden.');
        exitEditMode();
        return;
      }
      d[editIndex] = payload; 
      saveAll(d); 
      renderAllCards(); 
      exitEditMode();
      clearInput();
      await showModal('Der Schein wurde aktualisiert.');
    }else{
      if(d.length>=MAX_CARDS){
        await showModal('Limit erreicht: Es können maximal '+MAX_CARDS+' Scheine gespeichert werden.');
        return;
      }
      d.push(payload); saveAll(d); renderAllCards();
      clearInput();
      await showModal('Der Schein wurde gespeichert.');
    }
  }

  function setHitForNumber(numStr, on){
    const target = String(numStr);
    cardsWrap.querySelectorAll('table.saved-card').forEach(t=>{
      t.querySelectorAll('tbody td').forEach(td=>{
        if((td.dataset.num||'').trim()===target){
          if(on){ td.classList.add('hit'); } else { td.classList.remove('hit'); }
        }
      });
    });
  }

  function renderDrawnGrid(){
    const cols=[[],[],[],[],[]];
    for(const s of allDrawnNumbers){
      const n = parseInt(s,10);
      if(!Number.isInteger(n)) continue;
      if(n>=1 && n<=15) cols[0].push(n);
      else if(n<=30) cols[1].push(n);
      else if(n<=45) cols[2].push(n);
      else if(n<=60) cols[3].push(n);
      else if(n<=75) cols[4].push(n);
    }
    cols.forEach(c=>c.sort((a,b)=>a-b));
    const rows=Math.max(...cols.map(c=>c.length),0);

    const totalCards = loadAll().length;

    const makeCell = (val)=>{
      if(val==null) return '<td><div class="cell-inner">&nbsp;</div></td>';
      if(!highlightsOn){
        return `<td><div class="cell-inner"><span class="number-badge badge-neutral" data-num="${val}" title="Klicken zum Entfernen">${val}</span></div></td>`;
      }
      const cnt  = countCardsContainingNumber(String(val));
      let cls = 'badge-miss';
      if (totalCards > 0 && cnt === totalCards){
        cls = 'badge-all';
      } else if (cnt > 0){
        cls = 'badge-some';
      }
      return `<td><div class="cell-inner"><span class="number-badge ${cls}" data-num="${val}" title="Klicken zum Entfernen">${val}</span></div></td>`;
    };

    let html='';
    for(let r=0;r<rows;r++){
      html+='<tr>';
      for(let c=0;c<5;c++){ html+=makeCell(cols[c][r] ?? null); }
      html+='</tr>';
    }
    if(rows===0){
      html = '<tr><td colspan="5"><div class="cell-inner muted">Noch keine Zahlen vorhanden</div></td></tr>';
    }
    drawnGridBody.innerHTML = html;

    if(highlightsOn && allDrawnNumbers.length>0) show(legendBox); else hide(legendBox);
  }

  function updateUnifiedList(){
    if(!allDrawnNumbers.length){
      drawnGridBody.innerHTML = '<tr><td colspan="5"><div class="cell-inner muted">Noch keine Zahlen vorhanden</div></td></tr>';
      setNumbersDependentUI(false);
      refreshProgressBox();
      return;
    }
    renderDrawnGrid();
    setNumbersDependentUI(true);
    refreshProgressBox();
  }

  async function addNumberDirect(n){
    const s = String(n);
    if(allDrawnNumbers.includes(s)) return false;
    if(allDrawnNumbers.length >= MAX_DRAWN){
      await showModal(`Es dürfen maximal ${MAX_DRAWN} Zahlen eingetragen werden.`);
      return false;
    }
    if(!(Number.isInteger(n) && n>=1 && n<=75)) return false;
    allDrawnNumbers.push(s);
    applyHitsFromDrawnNumbers();
    updateUnifiedList();
    updateAll();
    return true;
  }

  function renderQuickGrid(){
    const cols = [
      Array.from({length:15}, (_,i)=>i+1),
      Array.from({length:15}, (_,i)=>i+16),
      Array.from({length:15}, (_,i)=>i+31),
      Array.from({length:15}, (_,i)=>i+46),
      Array.from({length:15}, (_,i)=>i+61)
    ];
    const chosen = new Set(allDrawnNumbers.map(Number));
    const rows = 15;
    let html='';
    for(let r=0; r<rows; r++){
      html += '<tr>';
      for(let c=0; c<5; c++){
        const num = cols[c][r];
        const chosenCls = chosen.has(num) ? 'q-chosen q-disabled' : '';
        html += `<td data-qnum="${num}" class="${chosenCls}"><div class="cell-inner">${num}</div></td>`;
      }
      html += '</tr>';
    }
    quickGridBody.innerHTML = html;
  }

  /* Schnellwahl: Klick auf Zahl */
  quickGridBody.addEventListener('click', async (e)=>{
    const td = e.target.closest('td[data-qnum]');
    if(!td) return;
    if(td.classList.contains('q-chosen')) return;
    const n = parseInt(td.getAttribute('data-qnum'),10);
    if(await addNumberDirect(n)){
      td.classList.add('q-chosen','q-disabled');
      await showModal('Die Zahl '+n+' wurde gespeichert.');
      scrollToResultsIfFull();
    }
  });

  /* Freitext-Eingabe bestätigen */
  async function markNumber(){
    if(allDrawnNumbers.length >= MAX_DRAWN){
      await showModal(`Es dürfen maximal ${MAX_DRAWN} Zahlen eingetragen werden.`);
      drawn.value='';
      return;
    }

    const raw = (drawn.value||'').split(/[,\s\.]+/).map(v=>v.trim()).filter(Boolean);
    const seen = new Set(allDrawnNumbers);
    const validIncoming = [];
    for(const v of raw){
      const n = Number(v);
      if(Number.isInteger(n) && n>=1 && n<=75){
        const s = String(n);
        if(!seen.has(s)){ validIncoming.push(s); seen.add(s); }
      }
    }
    if(validIncoming.length===0){
      await showModal('Bitte nur neue ganze Zahlen zwischen 1 und 75 eingeben (keine Duplikate).');
      return;
    }

    const remaining = MAX_DRAWN - allDrawnNumbers.length;
    const toAdd = validIncoming.slice(0, remaining);
    const cut = validIncoming.length - toAdd.length;

    for(const numStr of toAdd){ allDrawnNumbers.push(numStr); }

    applyHitsFromDrawnNumbers();
    updateUnifiedList();
    updateAll();

    if (toAdd.length===1){
      await showModal('Die Zahl '+toAdd[0]+' wurde gespeichert.');
    } else {
      await showModal('Die Zahlen '+toAdd.join(', ')+' wurden gespeichert.');
    }

    if(!quickPanel.classList.contains('d-none')) renderQuickGrid();

    drawn.value='';

    if(cut>0){
      await showModal('Es durften nur '+remaining+' weitere Zahlen eingetragen werden.');
    }

    scrollToResultsIfFull();
  }

  resetBtn.addEventListener('click', async (e)=>{
    e.preventDefault();
    const ok=await showConfirm('Wirklich ALLE gezogenen Zahlen zurücksetzen?', {okText:'Ja, zurücksetzen'});
    if(!ok) return;
    cardsWrap.querySelectorAll('.saved-card td.hit').forEach(td=>td.classList.remove('hit'));
    cardsWrap.querySelectorAll('.table-wrap').forEach(remLines);
    allDrawnNumbers = [];
    updateUnifiedList();
    lastResultsSignature = '';
    jumpedOn22 = false;
    updateAll();
    if(!quickPanel.classList.contains('d-none')) renderQuickGrid();
    await showModal('Zahlen zurückgesetzt.');
  });

  drawnGridBody.addEventListener('click', async (e)=>{
    const badge = e.target.closest('.number-badge'); 
    if(!badge) return;
    const numStr = badge.dataset.num;
    if(!numStr) return;
    const ok=await showConfirm('Möchtest du wirklich die Zahl '+numStr+' löschen?', {okText:'Ja, löschen'});
    if(!ok) return;
    allDrawnNumbers = allDrawnNumbers.filter(n => n !== numStr);
    applyHitsFromDrawnNumbers();
    cardsWrap.querySelectorAll('.table-wrap').forEach(remLines);
    updateUnifiedList();
    updateAll();
    if (allDrawnNumbers.length < MAX_DRAWN) jumpedOn22 = false;
    if(!quickPanel.classList.contains('d-none')) renderQuickGrid();
  });

  function resetToggleLabels(){
    toggleEntryBtn.textContent = '✏️ Zahleneingabe';
    toggleQuickBtn.textContent = '⚡ Zahlenschnellauswahl';
  }
  function showBothToggles(){
    toggleEntryBtn.classList.remove('d-none');
    toggleQuickBtn.classList.remove('d-none');
    hide(entryCloseSpacer);
    hide(quickCloseSpacer);
    resetToggleLabels();
  }
  function enterEntryMode(){
    toggleEntryBtn.textContent = '❌ Zahleneingabe schließen';
    toggleQuickBtn.classList.add('d-none');
    entryPanel.classList.remove('d-none');
    quickPanel.classList.add('d-none');
    show(entryCloseSpacer);
    hide(quickCloseSpacer);
  }
  function exitEntryMode(){
    entryPanel.classList.add('d-none');
    hide(entryCloseSpacer);
    showBothToggles();
  }
  function enterQuickMode(){
    toggleQuickBtn.textContent = '❌ Zahlenschnellauswahl schließen';
    toggleEntryBtn.classList.add('d-none');
    quickPanel.classList.remove('d-none');
    entryPanel.classList.add('d-none');
    renderQuickGrid();
    show(quickCloseSpacer);
    hide(entryCloseSpacer);
  }
  function exitQuickMode(){
    quickPanel.classList.add('d-none');
    hide(quickCloseSpacer);
    showBothToggles();
  }

  toggleEntryBtn.addEventListener('click', ()=>{
    if(entryPanel.classList.contains('d-none')){ enterEntryMode(); } else { exitEntryMode(); }
  });
  toggleQuickBtn.addEventListener('click', ()=>{
    if(quickPanel.classList.contains('d-none')){ enterQuickMode(); } else { exitQuickMode(); }
  });

  function updateTrefferampelButton(){
    highlightToggleBtn.textContent = highlightsOn ? '❌ Trefferampel deaktivieren' : '🎯 Trefferampel aktivieren';
  }
  highlightToggleBtn.addEventListener('click', ()=>{
    highlightsOn = !highlightsOn;
    updateTrefferampelButton();
    renderDrawnGrid();
  });
  updateTrefferampelButton();

  /* Kartenaktionen */
  cardsWrap.addEventListener('click', async (e)=>{
    const btn=e.target.closest('button'); if(!btn) return;
    const idx=+btn.dataset.idx; const d=loadAll();
    if(btn.dataset.act==='delete'){
      if(!d[idx]) return;
      const ok=await showConfirm('Diesen Schein wirklich löschen?', {okText:'Ja, löschen'});
      if(!ok) return;
      const deletedWasEditing=(editIndex===idx);
      d.splice(idx,1); saveAll(d);
      renderAllCards();
      if(deletedWasEditing) exitEditMode();
      await showModal('Der Schein wurde gelöscht.');
    }
    if(btn.dataset.act==='edit'){
      if(!d[idx]) return;
      enterEditMode(idx);
    }
  });

  deleteAllBtn.addEventListener('click', async ()=>{
    const d = loadAll();
    if(d.length===0){ return; }
    const ok=await showConfirm('Wirklich ALLE gespeicherten Scheine löschen?', {okText:'Ja, alles löschen'});
    if(!ok) return;
    localStorage.removeItem(STORAGE_KEY);
    renderAllCards();
    allDrawnNumbers=[];
    updateUnifiedList();
    lastResultsSignature = '';
    jumpedOn22 = false;
    updateAll();
    exitEditMode();
    clearInput();
    if(!quickPanel.classList.contains('d-none')) renderQuickGrid();
    await showModal('Alle Scheine wurden gelöscht.');
  });

  backToCheckBtn.addEventListener('click', ()=>{ $('checkTop').scrollIntoView({ behavior:'smooth', block:'start' }); });
  goToCheckBtn.addEventListener('click', ()=>{ $('checkTop').scrollIntoView({ behavior:'smooth', block:'start' }); });

  /* ===== Foto / OCR ===== */
  function updatePhotoButtons(){
    if(!hasImage){
      hide(photoBtnBar); hide(photoSpacerAfterButtons); hide(alignBtn); hide(finishAlignBtn); hide(deletePhotoBtn); hide(mobileRotate);
      show(photoHint);
      alignBtn.disabled = finishAlignBtn.disabled = deletePhotoBtn.disabled = true;
      return;
    }
    show(photoBtnBar); show(photoSpacerAfterButtons); hide(photoHint);
    deletePhotoBtn.disabled = false; show(deletePhotoBtn);
    if(alignActive){
      hide(alignBtn); show(finishAlignBtn); finishAlignBtn.disabled = false;
      isSmall() ? show(mobileRotate) : hide(mobileRotate);
    }else{
      show(alignBtn); alignBtn.disabled = false;
      hide(finishAlignBtn); finishAlignBtn.disabled = true;
      hide(mobileRotate);
    }
  }
  function enableAlignUI(on){
    alignActive = !!on;
    if(on){ cropOverlay.classList.remove('d-none'); cropOverlay.style.pointerEvents = 'auto'; }
    else  { cropOverlay.classList.add('d-none');  cropOverlay.style.pointerEvents = 'none'; }
    updatePhotoButtons();
  }
  function applyImgTransform(){ photoImage.style.transform = `translate(${imgOffset.x}px, ${imgOffset.y}px) scale(${imgScale})`; }
  function applyCropTransform(){ cropRect.style.transform = `rotate(${cropAngleDeg}deg)`; angleBadge.textContent = `${Math.round(cropAngleDeg)}°`; }

  function stylesToPxOnStage(){
    const stageRect = photoStage.getBoundingClientRect();
    const pL = parseFloat(cropRect.style.left)||0;
    const pT = parseFloat(cropRect.style.top)||0;
    const pW = parseFloat(cropRect.style.width)||0;
    const pH = parseFloat(cropRect.style.height)||0;
    const L = stageRect.width*(pL/100);
    const T = stageRect.height*(pT/100);
    const W = stageRect.width*(pW/100);
    const H = stageRect.height*(pH/100);
    return { L,T,W,H, stageRect };
  }
  function writePxAsPercent(L,T,W,H,stageRect){
    cropRect.style.left   = (L/stageRect.width)*100 + '%';
    cropRect.style.top    = (T/stageRect.height)*100 + '%';
    cropRect.style.width  = (W/stageRect.width)*100 + '%';
    cropRect.style.height = (H/stageRect.height)*100 + '%';
  }
  function getBaseContainRect(){
    const stageRect = photoStage.getBoundingClientRect();
    const imgAspect = photoImage.naturalWidth / photoImage.naturalHeight;
    const stageAspect = stageRect.width / stageRect.height;
    let visW, visH, offX, offY;
    if(imgAspect > stageAspect){
      visW = stageRect.width; visH = stageRect.width / imgAspect;
      offX = 0; offY = (stageRect.height - visH)/2;
    }else{
      visH = stageRect.height; visW = stageRect.height * imgAspect;
      offY = 0; offX = (stageRect.width - visW)/2;
    }
    return { left:offX, top:offY, width:visW, height:visH };
  }

  (function ensureCellBoxes(){
    const holder=$('cellBoxes');
    if(holder.childElementCount===25) return;
    for(let i=0;i<25;i++){ const box=document.createElement('div'); box.className='cell-box'; holder.appendChild(box); }
  })();

  const CROP_BORDER_PX=3, GRID_LINE_PX=2, GRID_INSET_PX=2, FUDGE_RIGHT_PX=8, FUDGE_BOTTOM_PX=8;

  function updateGrid(){
    const { W, H } = stylesToPxOnStage();
    const x0 = CROP_BORDER_PX + GRID_INSET_PX;
    const y0 = CROP_BORDER_PX + GRID_INSET_PX;
    const innerW = Math.max(0, W - (CROP_BORDER_PX + GRID_INSET_PX) - (CROP_BORDER_PX + GRID_INSET_PX + FUDGE_RIGHT_PX));
    const innerH = Math.max(0, H - (CROP_BORDER_PX + GRID_INSET_PX) - (CROP_BORDER_PX + GRID_INSET_PX + FUDGE_BOTTOM_PX));
    for(let i=1;i<=4;i++){
      const vx = x0 + innerW * (i/5);
      const v = cropRect.querySelector(`[data-grid="v${i}"]`);
      v.style.cssText = `left:${vx - (GRID_LINE_PX/2)}px; top:${y0}px; width:${GRID_LINE_PX}px; height:${innerH}px`;
      const hy = y0 + innerH * (i/5);
      const h = cropRect.querySelector(`[data-grid="h${i}"]`);
      h.style.cssText = `left:${x0}px; top:${hy - (GRID_LINE_PX/2)}px; width:${innerW}px; height:${GRID_LINE_PX}px`;
    }
    const boxes = $('cellBoxes').children;
    for(let r=0;r<5;r++){
      const yStart = y0 + innerH * (r/5) + (r>0 ? GRID_LINE_PX/2 : 0);
      const yEnd   = y0 + innerH * ((r+1)/5) - (r<4 ? GRID_LINE_PX/2 : 0);
      const ch = Math.max(0, yEnd - yStart);
      for(let c=0;c<5;c++){
        const idx = r*5+c, bx = boxes[idx];
        const xStart = x0 + innerW * (c/5) + (c>0 ? GRID_LINE_PX/2 : 0);
        const xEnd   = x0 + innerW * ((c+1)/5) - (c<4 ? GRID_LINE_PX/2 : 0);
        const cw = Math.max(0, xEnd - xStart);
        bx.style.left   = xStart + 'px';
        bx.style.top    = yStart + 'px';
        bx.style.width  = cw + 'px';
        bx.style.height = ch + 'px';
      }
    }
  }

  function getCropRectPixels(){
    const { L, T, W, H } = stylesToPxOnStage();
    const x = L + CROP_BORDER_PX + GRID_INSET_PX;
    const y = T + CROP_BORDER_PX + GRID_INSET_PX;
    const w = Math.max(0, W - (CROP_BORDER_PX + GRID_INSET_PX) - (CROP_BORDER_PX + GRID_INSET_PX + FUDGE_RIGHT_PX));
    const h = Math.max(0, H - (CROP_BORDER_PX + GRID_INSET_PX) - (CROP_BORDER_PX + GRID_INSET_PX + FUDGE_BOTTOM_PX));
    return { x, y, w, h };
  }

  function resetPhoto(){
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    photoImage.src=''; hasImage=false;
    photoStage.classList.add('d-none'); enableAlignUI(false);
    imgScale=1; imgOffset={x:0,y:0}; applyImgTransform();
    cropRect.style.left='10%'; cropRect.style.top='10%'; cropRect.style.width='80%'; cropRect.style.height='80%';
    cropAngleDeg=0; applyCropTransform();
    ocrProgressWrap.classList.add('d-none'); if (ocrProgressBarInner) ocrProgressBarInner.style.width='0%'; if (ocrStatus) ocrStatus.textContent='Bereit…';
    uploadInput.value = "";
    updatePhotoButtons();
  }

  uploadInput.addEventListener('click', ()=>{ uploadInput.value=""; }, {passive:true});

  uploadInput.addEventListener('change', (e)=>{
    const file=e.target.files && e.target.files[0];
    if(!file){ resetPhoto(); return; }
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    const url=URL.createObjectURL(file);
    currentObjectURL = url;
    photoImage.src=url;
    hasImage=true;
    photoStage.classList.remove('d-none');
    enableAlignUI(false);
    imgScale=1; imgOffset={x:0,y:0}; cropAngleDeg=0; applyImgTransform(); applyCropTransform();
    photoImage.onload=()=>{ updateGrid(); };
    updatePhotoButtons();
    uploadInput.value = "";
  }, {passive:true});

  deletePhotoBtn.addEventListener('click', resetPhoto);
  alignBtn.addEventListener('click', ()=>{ if(!hasImage) return; enableAlignUI(true); updateGrid(); $('betaTop').scrollIntoView({behavior:'smooth', block:'start'}); });
  finishAlignBtn.addEventListener('click', ()=>{ runOCRPipeline(); });

  const cropPointers = new Map(); let cropDragMode=null;
  function onPointerDown(e){
    if(!alignActive) return;
    const handle = e.target.closest('.handle');
    if(handle){ cropDragMode = (handle.dataset.h==='rot') ? 'rotate' : ('handle:'+handle.dataset.h); }
    else if(e.target === cropRect){ cropDragMode='moveRect'; }
    e.preventDefault(); e.stopPropagation();
    e.target.setPointerCapture?.(e.pointerId);
    cropPointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
  }
  function onPointerMove(e){
    if(!alignActive || !cropPointers.has(e.pointerId)) return;
    const { L:curL, T:curT, W:curW, H:curH, stageRect } = stylesToPxOnStage();
    const x = Math.max(0, Math.min(e.clientX - stageRect.left, stageRect.width));
    const y = Math.max(0, Math.min(e.clientY - stageRect.top , stageRect.height));

    if(cropDragMode==='rotate'){
      const ang1 = Math.atan2(y - (curT+curH/2), x - (curL+curW/2)) * 180/Math.PI;
      const delta = ang1 + 90;
      cropAngleDeg = clamp(delta, -45, 45);
      cropRect.style.transform = `rotate(${cropAngleDeg}deg)`;
      angleBadge.textContent = `${Math.round(cropAngleDeg)}°`;
      return;
    }

    if(cropDragMode && cropDragMode.startsWith('handle:')){
      const minSize=40;
      let L=curL, T=curT, W=curW, H=curH;
      const which=cropDragMode.split(':')[1];
      if(which==='tl'){
        const newL = Math.max(0, Math.min(x, curL+curW-minSize));
        const newT = Math.max(0, Math.min(y, curT+curH-minSize));
        W = (curL+curW)-newL; H = (curT+curH)-newT; L=newL; T=newT;
      }else if(which==='tr'){
        const newR = Math.max(curL+minSize, Math.min(x, stageRect.width));
        W = newR - curL;
        const newT = Math.max(0, Math.min(y, curT+curH-minSize));
        H = (curT+curH)-newT; T=newT;
      }else if(which==='bl'){
        const newB = Math.max(curT+minSize, Math.min(y, stageRect.height));
        H = newB - curT;
        const newL = Math.max(0, Math.min(x, curL+curW-minSize));
        W = (curL+curW)-newL; L=newL;
      }else if(which==='br'){
        const newR = Math.max(curL+minSize, Math.min(x, stageRect.width));
        const newB = Math.max(curT+minSize, Math.min(y, stageRect.height));
        W = newR - curL; H = newB - curT;
      }
      writePxAsPercent(L,T,W,H,stageRect);
      updateGrid();
      return;
    }

    if(cropDragMode==='moveRect'){
      let L = clamp(x - curW/2, 0, stageRect.width - curW);
      let T = clamp(y - curH/2, 0, stageRect.height - curH);
      writePxAsPercent(L,T,curW,curH,stageRect);
      updateGrid();
      return;
    }
  }
  function onPointerUp(e){
    cropPointers.delete(e.pointerId);
    if(cropPointers.size===0){ cropDragMode=null; }
    e.target.releasePointerCapture?.(e.pointerId);
  }
  cropRect.addEventListener('pointerdown', onPointerDown, {passive:false});
  cropRect.addEventListener('pointermove', onPointerMove, {passive:false});
  cropRect.addEventListener('pointerup', onPointerUp, {passive:false});
  cropRect.addEventListener('pointercancel', onPointerUp, {passive:false});

  function setOcrProgress(pct, text){
    ocrProgressWrap.classList.remove('d-none');
    if (ocrProgressBarInner) ocrProgressBarInner.style.width = Math.round(pct)+'%';
    if(text) ocrStatus.textContent = text;
  }

  async function runCellOCR(bigCanvas){
    const W=bigCanvas.width, H=bigCanvas.height;
    const cw=Math.floor(W/5), ch=Math.floor(H/5);
    const results=[];
    const baseCtx=bigCanvas.getContext('2d', { willReadFrequently: true });

    const worker = await Tesseract.createWorker('deu+eng');
    await worker.setParameters({
      tessedit_char_whitelist:'0123456789',
      tessedit_do_invert:'1',
      preserve_interword_spaces:'1'
    });

    function toGray(ctx, sx, sy, sw, sh){
      const id = ctx.getImageData(sx,sy,sw,sh);
      const d=id.data;
      const g=new Uint8ClampedArray(sw*sh);
      for(let i=0,j=0;i<d.length;i+=4, j++){
        g[j]=(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2])|0;
        d[i]=d[i+1]=d[i+2]=g[j]; d[i+3]=255;
      }
      return { id, gray:g };
    }
    function otsuThreshold(gray, w, h){
      const hist = new Uint32Array(256);
      for(let i=0;i<gray.length;i++) hist[gray[i]]++;
      const total=w*h; let sum=0;
      for(let t=0;t<256;t++) sum+=t*hist[t];
      let sumB=0, wB=0, varMax=-1, thr=127;
      for(let t=0;t<256;t++){
        wB += hist[t]; if(wB===0) continue;
        const wF = total - wB; if(wF===0) break;
        sumB += t*hist[t];
        const mB = sumB/wB;
        const mF = (sum - sumB)/wF;
        const between = wB*wF*(mB-mF)*(mB-mF);
        if(between>varMax){ varMax=between; thr=t; }
      }
      return thr;
    }
    function binarize(gray, w, h, mode){
      const out=new Uint8ClampedArray(w*h*4);
      const thr = mode.type==='global' ? (mode.thr ?? 128) : otsuThreshold(gray,w,h);
      for(let i=0,j=0;i<gray.length;i++,j+=4){
        let v = gray[i] > thr ? 255 : 0;
        if(mode.invert) v = 255 - v;
        out[j]=out[j+1]=out[j+2]=v; out[j+3]=255;
      }
      return out;
    }
    function paintRGBA(ctx, x, y, w, h, rgba){
      const id = ctx.createImageData(w,h);
      id.data.set(rgba);
      ctx.putImageData(id, x, y);
    }

    let done=0, total=25;
    for(let r=0;r<5;r++){
      for(let c=0;c<5;c++){
        const tmp=document.createElement('canvas');
        tmp.width=cw; tmp.height=ch;
        const tctx=tmp.getContext('2d', { willReadFrequently: true });

        const padX=Math.floor(cw*0.10), padY=Math.floor(ch*0.10);
        const sx=c*cw+padX, sy=r*ch+padY, sw=cw-2*padX, sh=ch-padY*2;

        const { id, gray } = toGray(baseCtx, sx, sy, sw, sh);
        const avg = gray.reduce((a,v)=>a+v,0)/gray.length;
        const thrGlobal = Math.max(64, Math.min(200, avg*0.92));
        const variants = [
          { type:'global', invert:false, thr:thrGlobal },
          { type:'otsu',   invert:false },
          { type:'global', invert:true, thr:255-thrGlobal }
        ];
        let best={ num:null, conf:-1, raw:'' };
        for(const mode of variants){
          const bin=binarize(gray, sw, sh, mode);
          tctx.clearRect(0,0,cw,ch);
          paintRGBA(tctx, 0,0, sw,sh, bin);
          await worker.setParameters({ tessedit_pageseg_mode: Tesseract.PSM.SINGLE_WORD });
          const { data } = await worker.recognize(tmp);
          let conf=0, text=data.text||'';
          if(data && Array.isArray(data.words) && data.words.length){
            conf = data.words.reduce((a,w)=>a+w.confidence,0) / data.words.length;
          } else if(typeof data.confidence==='number'){ conf=data.confidence; }
          const m=(text||'').match(/\d{1,2}/);
          const cand = { num: m ? parseInt(m[0],10) : null, conf: conf||0, raw:(text||'').replace(/\D+/g,'') };
          if(cand.conf>best.conf && cand.num!=null){ best=cand; }
        }
        const [mn,mx]=COL_RANGES[c];
        if(best.num!=null && (best.num<mn || best.num>mx) && best.conf<60){
          best.num=null;
        }
        results.push({ num:best.num, conf:best.conf, raw:best.raw, row:r, col:c });
        done++; setOcrProgress((done/total)*100, `Erkenne Zellen… (${done}/${total})`);
        await new Promise(rq=>setTimeout(rq, 2));
      }
    }
    await worker.terminate();
    return results;
  }

  function fillInputTable(nums){
    const inputs = getInputs();
    inputs.forEach((inp, i)=>{
      const n = nums[i];
      if(n==null || Number.isNaN(n)){ inp.value=''; return; }
      const col = i % 5;
      const [min,max] = COL_RANGES[col];
      if(n>=min && n<=max){ inp.value = String(n); }
      else{
        inp.value=''; 
        inp.classList.add('invalid-cell');
      }
    });
    liveValidate();
  }

  function preprocessRotatedToCanvas(imgEl, rectPx, angleDeg){
    const angle = angleDeg * Math.PI/180;
    const { x, y, w, h } = rectPx;
    const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
    const outWBase = 1500;
    const outW = isIOS ? 1300 : outWBase; /* etwas kleiner auf iPhone für bessere Performance */
    const outH = Math.round(h * (outW / w));
    const canvas = document.createElement('canvas'); canvas.width = outW; canvas.height = outH;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const base = getBaseContainRect();
    const visW = base.width, visH = base.height;
    const effW = visW * imgScale;
    const effH = visH * imgScale;
    const effLeft = base.left + imgOffset.x + (visW - effW)/2;
    const effTop  = base.top  + (visH - effH)/2 + imgOffset.y;

    const cx = x + w/2, cy = y + h/2;

    ctx.translate(outW/2, outH/2);
    ctx.rotate(-angle);
    ctx.scale(outW / w, outW / w);
    ctx.translate(-cx, -cy);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(imgEl, effLeft, effTop, effW, effH);

    const id = ctx.getImageData(0,0,outW,outH);
    const d = id.data; let sum=0;
    for(let i=0;i<d.length;i+=4){ sum += 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }
    const avg = sum/(d.length/4), gain = 1.25;
    for(let i2=0;i2<d.length;i2+=4){
      const g = (0.2126*d[i2]+0.7152*d[i2+1]+0.0722*d[i2+2]);
      const v = (g - avg) * gain + avg;
      d[i2]=d[i2+1]=d[i2+2]=v; d[i2+3]=255;
    }
    ctx.putImageData(id,0,0);
    return canvas;
  }

  async function runOCRPipeline(){
    if(!photoImage.src){ return; }
    ocrProgressWrap.classList.remove('d-none');
    if (ocrProgressBarInner) ocrProgressBarInner.style.width='2%';
    if (ocrStatus) ocrStatus.textContent='Bereite Bild vor…';
    try{
      const rectPx=getCropRectPixels();
      const prepCanvas=preprocessRotatedToCanvas(photoImage, rectPx, cropAngleDeg);
      if (ocrProgressBarInner) ocrProgressBarInner.style.width='8%';
      if (ocrStatus) ocrStatus.textContent='Schneide Zellen…';

      const results = await runCellOCR(prepCanvas);
      const fixedNums = results.map((cell)=>{
        const [mn,mx]=COL_RANGES[cell.col];
        let n = cell.num;
        if(Number.isInteger(n) && n>=mn && n<=mx) return n;

        const raw = cell.raw||'';
        const outSet = new Set([raw]);
        if(raw.length===2 && raw[0]==='0') outSet.add(raw[1]);
        const DIGIT_CONFUSIONS={
          '0':['6','8'],'1':['7','4'],'2':['7'],'3':['8','5'],'4':['1','9'],
          '5':['6','3'],'6':['5','8','0'],'7':['1','2'],'8':['6','3','9','0'],'9':['8','4']
        };
        for(let i=0;i<raw.length;i++){
          for(const alt of (DIGIT_CONFUSIONS[raw[i]]||[])){ outSet.add(raw.slice(0,i)+alt+raw.slice(i+1)); }
        }
        const validInCol=[], validOverall=[];
        for(const s of outSet){
          const nn=parseInt(s,10);
          if(Number.isInteger(nn) && nn>=1 && nn<=75){
            if(nn>=mn && nn<=mx) validInCol.push(nn); else validOverall.push(nn);
          }
        }
        if(validInCol.length) return validInCol[0];
        if(validOverall.length) return validOverall[0];
        return n ?? null;
      });

      fillInputTable(fixedNums);
      enableAlignUI(false);
      if (ocrProgressBarInner) ocrProgressBarInner.style.width='100%';
      if (ocrStatus) ocrStatus.textContent='Fertig.';
      await showModal('Erkannte Zahlen wurden eingefügt. Bitte prüfe die Felder trotzdem');
      $('top').scrollIntoView({behavior:'smooth', block:'start'});
    }catch(err){
      console.error(err);
      await showModal('Konnte die Zahlen nicht zuverlässig erkennen. Bitte besser ausrichten/ausleuchten oder näher zoomen.');
    }finally{
      setTimeout(()=>{ ocrProgressWrap.classList.add('d-none'); if (ocrProgressBarInner) ocrProgressBarInner.style.width='0%'; if (ocrStatus) ocrStatus.textContent='Bereit…'; }, 800);
    }
  }

  /* Init */
  try{
    if(!document.querySelector('#inputBody tr')){
      for(let r=0;r<5;r++){
        const tr=document.createElement('tr');
        for(let c=0;c<5;c++){
          const [min,max]=COL_RANGES[c];
          tr.innerHTML += `<td><input class="cell-inp" type="number" min="${min}" max="${max}" step="1" placeholder="${min}-${max}"></td>`;
        }
        inputBody.appendChild(tr);
      }
    }

    /* Events */
    saveBtn.addEventListener('click', ()=>{ saveCard(); });
    saveCancelBtn.addEventListener('click', ()=>{ exitEditMode(); clearInput(); });
    clearBtn.addEventListener('click', async ()=>{ const ok=await showConfirm('Alle Eingaben in diesem Bereich wirklich löschen?', {okText:'Ja, löschen'}); if(ok) clearInput(); });

    markBtn.addEventListener('click', (e)=>{ e.preventDefault(); markNumber(); });
    inputBody.addEventListener('input', liveValidate, {passive:true});

    /* Start */
    liveValidate();
    renderAllCards();
    updateAll();

    entryPanel.classList.add('d-none');
    quickPanel.classList.add('d-none');
    toggleEntryBtn.classList.remove('d-none');
    toggleQuickBtn.classList.remove('d-none');
    hide(entryCloseSpacer);
    hide(quickCloseSpacer);

  }catch(err){
    console.error('Init-Fehler:', err);
    showModal('Es ist ein Fehler beim Initialisieren aufgetreten. Details in der Konsole.');
  }
})();
</script>

</body>
</html>
